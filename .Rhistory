}
redundancy_check(ae$X)
intelliRep <- function(v, simplify = 1){
if (!is.atomic(v)) stop('v should be an atomic vector.')
v.unique <- unique(v)
nRep <- sapply(v.unique, function(v.this) sum(v = v.this))
nRep.unique <- unique(nRep)
if (simplify) return(nRep.unique)
else return(nRep)
}
redundancy_check(ae$X)
redundancy_check <- function(v, repNo = 2, upLimit = 0.5, silent = FALSE, outClass = c('checkResult.306', 'checkResult')){
#### Arguments check ####
if (ncol(as.data.frame(v)) > 1) stop('This function is for vector only. Use the loners_scan instead.')
if (!requireNamespace('dataMaid')) stop('Please install dataMaid package before continuing.')
repNo <- suppressWarnings(as.numeric(repNo))
if (is.na(repNo) | is.null(repNo)) repNo <- 2
if (any(is.na(upLimit), is.null(upLimit), !is.numeric(upLimit))) upLimit <- 0.5
else while (upLimit > 1) upLimit <- upLimit/10
silent <- as.logical(silent)
if (any(is.na(silent), is.null(silent))) silent <- FALSE
if (any(is.na(outClass), is.null(outClass))) outClass <- 'checkResult.306' else outClass <- match.arg(outClass)
if (exists('shinyOn')) if (shinyOn == TRUE) silent <- TRUE
#### Preparation of Outputs ####
problem <- logical(0)
problemValues <- NULL
problemIndexes <- NULL
message <- list()
#### Apply the check on variable ####
if (any(intelliRep(v) != repNo)) {
diff <- setdiff(intelliRep(v), repNo)
rep.full <- intelliRep(v, simplify = FALSE)
rep.pos <- which(rep.full %in% diff)
v.pos <- sapply(rep.pos, function(pos) sum(rep.full[1:pos-1]))
if (length(v.pos)/length(v) <= upLimit){
problem <- TRUE
problemValues <- sapply(seq_along(rep.pos), function(i) paste0(v[v.pos[[i]]], ' [', rep.full[rep.pos[[i]]], ']'))
problemIndexes <- v.pos
message <-  'These $display$ might $behave$ potential redundancy:'
} else {
problem <- FALSE
message <- sprintf('We notice redundancy within your variable. However, this might be a wrong conclusion due to their overly high frequency (~%d%%).\n>>> Set upLimit to a higher value to override this behavior.', floor(upLimit * 100))
}
} else {
problem <- FALSE
message <- 'No problems found'
}
}
redundancy_check(ae$X)
redundancy_check <- function(v, repNo = 2, upLimit = 0.5, silent = FALSE, outClass = c('checkResult.306', 'checkResult')){
#### Arguments check ####
if (ncol(as.data.frame(v)) > 1) stop('This function is for vector only. Use the loners_scan instead.')
if (!requireNamespace('dataMaid')) stop('Please install dataMaid package before continuing.')
repNo <- suppressWarnings(as.numeric(repNo))
if (is.na(repNo) | is.null(repNo)) repNo <- 2
if (any(is.na(upLimit), is.null(upLimit), !is.numeric(upLimit))) upLimit <- 0.5
else while (upLimit > 1) upLimit <- upLimit/10
silent <- as.logical(silent)
if (any(is.na(silent), is.null(silent))) silent <- FALSE
if (any(is.na(outClass), is.null(outClass))) outClass <- 'checkResult.306' else outClass <- match.arg(outClass)
if (exists('shinyOn')) if (shinyOn == TRUE) silent <- TRUE
#### Preparation of Outputs ####
problem <- logical(0)
problemValues <- NULL
problemIndexes <- NULL
message <- list()
#### Apply the check on variable ####
if (any(intelliRep(v) != repNo)) {
diff <- setdiff(intelliRep(v), repNo)
rep.full <- intelliRep(v, simplify = FALSE)
rep.pos <- which(rep.full %in% diff)
v.pos <- sapply(rep.pos, function(pos) sum(rep.full[1:pos-1]))
if (length(v.pos)/length(v) <= upLimit){
problem <- TRUE
problemValues <- sapply(seq_along(rep.pos), function(i) paste0(v[v.pos[[i]]], ' [', rep.full[rep.pos[[i]]], ']'))
problemIndexes <- v.pos
message <-  'These $display$ might $behave$ potential redundancy:'
} else {
problem <- FALSE
message <- sprintf('We notice redundancy within your variable. However, this might be a wrong conclusion due to their overly high frequency (~%d%%).\n>>> Set upLimit to a higher value to override this behavior.', floor(upLimit * 100))
}
} else {
problem <- FALSE
message <- 'No problems found'
}
#### Return the output ####
out <- cR306_init(testName = 'redundancy issues', outClass = outClass,
problem = problem, problemValues = problemValues, problemIndexes = problemIndexes, problemKeys = problemIndexes, message = message, res = is.Wrong)
return(out)
}
redundancy_check(ae$X)
redundancy_check <- function(v, repNo = 2, upLimit = 0.5, silent = FALSE, outClass = c('checkResult.306', 'checkResult')){
#### Arguments check ####
if (ncol(as.data.frame(v)) > 1) stop('This function is for vector only. Use the loners_scan instead.')
if (!requireNamespace('dataMaid')) stop('Please install dataMaid package before continuing.')
repNo <- suppressWarnings(as.numeric(repNo))
if (is.na(repNo) | is.null(repNo)) repNo <- 2
if (any(is.na(upLimit), is.null(upLimit), !is.numeric(upLimit))) upLimit <- 0.5
else while (upLimit > 1) upLimit <- upLimit/10
silent <- as.logical(silent)
if (any(is.na(silent), is.null(silent))) silent <- FALSE
if (any(is.na(outClass), is.null(outClass))) outClass <- 'checkResult.306' else outClass <- match.arg(outClass)
if (exists('shinyOn')) if (shinyOn == TRUE) silent <- TRUE
#### Preparation of Outputs ####
problem <- logical(0)
problemValues <- NULL
problemIndexes <- NULL
message <- list()
#### Apply the check on variable ####
if (any(intelliRep(v) != repNo)) {
diff <- setdiff(intelliRep(v), repNo)
rep.full <- intelliRep(v, simplify = FALSE)
rep.pos <- which(rep.full %in% diff)
v.pos <- sapply(rep.pos, function(pos) sum(rep.full[1:pos-1]))
if (length(v.pos)/length(v) <= upLimit){
problem <- TRUE
problemValues <- v[v.pos]
problemIndexes <- v.pos
message <-  'These $display$ might $behave$ potential redundancy:'
res <- rep.full[rep.pos]
} else {
problem <- FALSE
message <- sprintf('We notice redundancy within your variable. However, this might be a wrong conclusion due to their overly high frequency (~%d%%).\n>>> Set upLimit to a higher value to override this behavior.', floor(upLimit * 100))
}
} else {
problem <- FALSE
message <- 'No problems found'
}
#### Return the output ####
out <- cR306_init(testName = 'redundancy issues', outClass = outClass,
problem = problem, problemValues = problemValues, problemIndexes = problemIndexes, problemKeys = problemIndexes, message = message, res = is.Wrong)
return(out)
}
redundancy_check <- function(v, repNo = 2, upLimit = 0.5, silent = FALSE, outClass = c('checkResult.306', 'checkResult')){
#### Arguments check ####
if (ncol(as.data.frame(v)) > 1) stop('This function is for vector only. Use the loners_scan instead.')
if (!requireNamespace('dataMaid')) stop('Please install dataMaid package before continuing.')
repNo <- suppressWarnings(as.numeric(repNo))
if (is.na(repNo) | is.null(repNo)) repNo <- 2
if (any(is.na(upLimit), is.null(upLimit), !is.numeric(upLimit))) upLimit <- 0.5
else while (upLimit > 1) upLimit <- upLimit/10
silent <- as.logical(silent)
if (any(is.na(silent), is.null(silent))) silent <- FALSE
if (any(is.na(outClass), is.null(outClass))) outClass <- 'checkResult.306' else outClass <- match.arg(outClass)
if (exists('shinyOn')) if (shinyOn == TRUE) silent <- TRUE
#### Preparation of Outputs ####
problem <- logical(0)
problemValues <- NULL
problemIndexes <- NULL
message <- list()
#### Apply the check on variable ####
if (any(intelliRep(v) != repNo)) {
diff <- setdiff(intelliRep(v), repNo)
rep.full <- intelliRep(v, simplify = FALSE)
rep.pos <- which(rep.full %in% diff)
v.pos <- sapply(rep.pos, function(pos) sum(rep.full[1:pos-1]))
if (length(v.pos)/length(v) <= upLimit){
problem <- TRUE
problemValues <- v[v.pos]
problemIndexes <- v.pos
message <-  'These $display$ might $behave$ potential redundancy:'
res <- rep.full[rep.pos]
} else {
problem <- FALSE
message <- sprintf('We notice redundancy within your variable. However, this might be a wrong conclusion due to their overly high frequency (~%d%%).\n>>> Set upLimit to a higher value to override this behavior.', floor(upLimit * 100))
}
} else {
problem <- FALSE
message <- 'No problems found'
}
#### Return the output ####
out <- cR306_init(testName = 'redundancy issues', outClass = outClass,
problem = problem, problemValues = problemValues, problemIndexes = problemIndexes, problemKeys = problemIndexes, message = message, res = res)
return(out)
}
redundancy_check(ae$X)
redundancy_check <- function(v, repNo = 2, upLimit = 0.5, silent = FALSE, outClass = c('checkResult.306', 'checkResult')){
#### Arguments check ####
if (ncol(as.data.frame(v)) > 1) stop('This function is for vector only. Use the loners_scan instead.')
if (!requireNamespace('dataMaid')) stop('Please install dataMaid package before continuing.')
repNo <- suppressWarnings(as.numeric(repNo))
if (is.na(repNo) | is.null(repNo)) repNo <- 2
if (any(is.na(upLimit), is.null(upLimit), !is.numeric(upLimit))) upLimit <- 0.5
else while (upLimit > 1) upLimit <- upLimit/10
silent <- as.logical(silent)
if (any(is.na(silent), is.null(silent))) silent <- FALSE
if (any(is.na(outClass), is.null(outClass))) outClass <- 'checkResult.306' else outClass <- match.arg(outClass)
if (exists('shinyOn')) if (shinyOn == TRUE) silent <- TRUE
#### Preparation of Outputs ####
problem <- logical(0)
problemValues <- NULL
problemIndexes <- NULL
res <- NULL
message <- list()
#### Apply the check on variable ####
if (any(intelliRep(v) != repNo)) {
diff <- setdiff(intelliRep(v), repNo)
rep.full <- intelliRep(v, simplify = FALSE)
rep.pos <- which(rep.full %in% diff)
v.pos <- sapply(rep.pos, function(pos) sum(rep.full[1:pos-1]))
if (length(v.pos)/length(v) <= upLimit){
problem <- TRUE
problemValues <- v[v.pos]
problemIndexes <- v.pos
message <-  'These $display$ might $behave$ potential redundancy:'
res <- rep.full[rep.pos]
} else {
problem <- FALSE
message <- sprintf('We notice redundancy within your variable. However, this might be a wrong conclusion due to their overly high frequency (~%d%%).\n>>> Set upLimit to a higher value to override this behavior.', floor(upLimit * 100))
}
} else {
problem <- FALSE
message <- 'No problems found'
}
#### Return the output ####
out <- cR306_init(testName = 'redundancy issues', outClass = outClass,
problem = problem, problemValues = problemValues, problemIndexes = problemIndexes, problemKeys = problemIndexes, message = message, res = res)
return(out)
}
redundancy_check(ae$X)
redundancy_check(ae$X, upLimit = 1)
ae$X
intelliRep(ae$X)
intelliRep <- function(v, simplify = 1){
if (!is.atomic(v)) stop('v should be an atomic vector.')
v.unique <- unique(v)
nRep <- sapply(v.unique, function(v.this) sum(v == v.this))
nRep.unique <- unique(nRep)
if (simplify) return(nRep.unique)
else return(nRep)
}
intelliRep(ae$X)
redundancy_check(ae$X,repNo = 1, upLimit = 1)
redundancy_check(ae$X,repNo = 2, upLimit = 1)
c(1,1,2,2,3,3,4,4)
v = c(1,1,2,2,3,3,4,4)
redundancy_check(v,repNo = 2, upLimit = 1)
v = c(1,1,2,2,3,3,4,4,4)
redundancy_check(v,repNo = 2, upLimit = 1)
nRep(v)
intelliRep(v)
intelliRep(v) != 2
setdiff(intelliRep(v), 2)
intelliRep(v, simplify = F)
repNo = 2
diff <- setdiff(intelliRep(v), repNo)
rep.full <- intelliRep(v, simplify = FALSE)
rep.pos <- which(rep.full %in% diff)
v.pos <- sapply(rep.pos, function(pos) sum(rep.full[1:pos-1]))
diff
rep.full
rep.pos
vpos
v.pos
v
redundancy_check <- function(v, repNo = 2, upLimit = 0.5, silent = FALSE, outClass = c('checkResult.306', 'checkResult')){
#### Arguments check ####
if (ncol(as.data.frame(v)) > 1) stop('This function is for vector only. Use the loners_scan instead.')
if (!requireNamespace('dataMaid')) stop('Please install dataMaid package before continuing.')
repNo <- suppressWarnings(as.numeric(repNo))
if (is.na(repNo) | is.null(repNo)) repNo <- 2
if (any(is.na(upLimit), is.null(upLimit), !is.numeric(upLimit))) upLimit <- 0.5
else while (upLimit > 1) upLimit <- upLimit/10
silent <- as.logical(silent)
if (any(is.na(silent), is.null(silent))) silent <- FALSE
if (any(is.na(outClass), is.null(outClass))) outClass <- 'checkResult.306' else outClass <- match.arg(outClass)
if (exists('shinyOn')) if (shinyOn == TRUE) silent <- TRUE
#### Preparation of Outputs ####
problem <- logical(0)
problemValues <- NULL
problemIndexes <- NULL
res <- NULL
message <- list()
#### Apply the check on variable ####
if (any(intelliRep(v) != repNo)) {
diff <- setdiff(intelliRep(v), repNo)
rep.full <- intelliRep(v, simplify = FALSE)
rep.pos <- which(rep.full %in% diff)
v.pos <- sapply(rep.pos, function(pos) sum(rep.full[1:pos-1]) + 1)
if (length(v.pos)/length(v) <= upLimit){
problem <- TRUE
problemValues <- v[v.pos]
problemIndexes <- v.pos
message <-  'These $display$ might $behave$ potential redundancy:'
res <- rep.full[rep.pos]
} else {
problem <- FALSE
message <- sprintf('We notice redundancy within your variable. However, this might be a wrong conclusion due to their overly high frequency (~%d%%).\n>>> Set upLimit to a higher value to override this behavior.', floor(upLimit * 100))
}
} else {
problem <- FALSE
message <- 'No problems found'
}
#### Return the output ####
out <- cR306_init(testName = 'redundancy issues', outClass = outClass,
problem = problem, problemValues = problemValues, problemIndexes = problemIndexes, problemKeys = problemIndexes, message = message, res = res)
return(out)
}
redundancy_check(v,repNo = 2, upLimit = 1)
redundancy_check(v,repNo = 2, upLimit = 1)%>% print(display = 'k')
redundancy_check(v,repNo = 2, upLimit = 1)%>% print(display = 'i')
displayValues.string <- toString(ifelse(displayName == 'values' & !is.na(displayValues), paste0('“', displayValues, '”'), displayValues))
messageGenerator.306 <- function(message, displayName = c('keys', 'indexes', 'values'), displayValues, nMax){
if (!is.numeric(nMax)) stop('nMax must be integer')
nMax <- abs(nMax)
displayName <- match.arg(displayName)
message <- sub('$display$', displayName, message, fixed = TRUE)
message <- sub('$behave$', if (displayName == 'values') 'be' else 'have', message, fixed = TRUE)
suffix <- ''
if (nMax < length(displayValues)) {
deltaL <- length(displayValues) - nMax
displayValues <- displayValues[1:nMax]
suffix <- sprintf(' (and %d more)', deltaL)
}
displayValues.string <- toString(ifelse(displayName == 'values' & !is.na(displayValues), paste0('“', displayValues, '”'), displayValues))
out <- sprintf('%s %s%s', message, displayValues.string, suffix)
return(out)
}
redundancy_check(v,repNo = 2, upLimit = 1)
sprintf('%s (and %d more)',
toString(ifelse(!is.na(displayValues[[test,var]][1:nMax]),
if (display == 'values')
paste0('“', displayValues[[test,var]][1:nMax], '”')
else
displayValues[[test,var]][1:nMax],
NA)),
length(displayValues[[test,var]]) - nMax)
source('C:/Users/trinhdhk/OneDrive/Works/Git/dataCleaner/includes/cleanifyGroup.R', encoding = 'UTF-8', echo=TRUE)
redundancy_check(v,repNo = 2, upLimit = 1)
all_check(v)
all_check <- function(v, v.type = intelliType(v), checks = c('missing', 'whitespaces', 'doubleWSP', 'spelling', 'outliers', 'binary', 'loners', 'redundancy'), options = opt(), silent = FALSE, outClass = c('checkResult.306', 'checkResult')){
#### Arguments check ####
if (ncol(as.data.frame(v)) > 1) stop('This function is for vector only. Use cleanify instead.')
if (!requireNamespace('dataMaid')) stop('Please install dataMaid package before continuing.')
if (!requireNamespace('hunspell')) stop('Please install hunspell package before continuing.')
silent <- as.logical(silent)
if (any(is.na(silent), is.null(silent))) silent <- FALSE
if (any(is.na(outClass), is.null(outClass))) outClass <- 'checkResult.306' else outClass <- match.arg(outClass)
if (exists('shinyOn')) if (shinyOn == TRUE) silent <- TRUE
if (missing(options)) options <- list()
#### Preparation of the output ####
res <- list()
#### Get default options ####
defaultOpt <- getDefaultOptions(v.type)
#### Update options ####
options <- update.list(defaultOpt, options, add = TRUE)
#### Check the input for compatibilty ####
is.supported <- intelliCompatible(data = v, tests = checks, accept.dateTime = options$loners$accept.dateTime)
checks <- checks[is.supported]
#### Run the check ####
for (i in 1:length(checks)) {
res[i] <- as.list(res[i])
res[[i]] <- switch(checks[[i]],
missing = missing_check(v, silent = silent, outClass = outClass),
whitespaces = whitespaces_check(v, silent = silent, outClass = outClass),
doubleWSP = doubleWSP_check(v, silent = silent, outClass = outClass),
outliers = outliers_check(v, v.type = v.type,
model = options$outliers$model, skewParam = options$outliers$skewParam,
customFn = option$outliers$customFn,
accept.negative = options$outliers$accept.negative, accept.zero = options$outliers$accept.zero,
silent = silent, outClass = outClass),
loners = loners_check(v, v.type = v.type,
accept.dateTime = options$loners$accept.dateTime,
threshold = options$loners$threshold, upLimit = options$loners$upLimit,
silent = silent, outClass = outClass),
binary = binary_check(v, upLimit = options$binary$upLimit,
silent = silent, outClass = outClass),
spelling = spelling_check(v, v.type,
upLimit = options$spelling$upLimit,
silent = silent, outClass = outClass),
redundancy = redundancy_check(v,
repNo = options$redundancy$repNo,
upLimit = options$redundancy$upLimit,
silent = silent, outClass = outClass))
}
names(res) <- checks
class(res) <- c('checkResult.306.all_check')
return(res)
}
all_check(v)
all_check <- function(v, v.type = intelliType(v), checks = c('missing', 'whitespaces', 'doubleWSP', 'spelling', 'outliers', 'binary', 'loners'), options = opt(), silent = FALSE, outClass = c('checkResult.306', 'checkResult')){
#### Arguments check ####
if (ncol(as.data.frame(v)) > 1) stop('This function is for vector only. Use cleanify instead.')
if (!requireNamespace('dataMaid')) stop('Please install dataMaid package before continuing.')
if (!requireNamespace('hunspell')) stop('Please install hunspell package before continuing.')
silent <- as.logical(silent)
if (any(is.na(silent), is.null(silent))) silent <- FALSE
if (any(is.na(outClass), is.null(outClass))) outClass <- 'checkResult.306' else outClass <- match.arg(outClass)
if (exists('shinyOn')) if (shinyOn == TRUE) silent <- TRUE
if (missing(options)) options <- list()
#### Preparation of the output ####
res <- list()
#### Get default options ####
defaultOpt <- getDefaultOptions(v.type)
#### Update options ####
options <- update.list(defaultOpt, options, add = TRUE)
#### Check the input for compatibilty ####
is.supported <- intelliCompatible(data = v, tests = checks, accept.dateTime = options$loners$accept.dateTime)
checks <- checks[is.supported]
#### Run the check ####
for (i in 1:length(checks)) {
res[i] <- as.list(res[i])
res[[i]] <- switch(checks[[i]],
missing = missing_check(v, silent = silent, outClass = outClass),
whitespaces = whitespaces_check(v, silent = silent, outClass = outClass),
doubleWSP = doubleWSP_check(v, silent = silent, outClass = outClass),
outliers = outliers_check(v, v.type = v.type,
model = options$outliers$model, skewParam = options$outliers$skewParam,
customFn = option$outliers$customFn,
accept.negative = options$outliers$accept.negative, accept.zero = options$outliers$accept.zero,
silent = silent, outClass = outClass),
loners = loners_check(v, v.type = v.type,
accept.dateTime = options$loners$accept.dateTime,
threshold = options$loners$threshold, upLimit = options$loners$upLimit,
silent = silent, outClass = outClass),
binary = binary_check(v, upLimit = options$binary$upLimit,
silent = silent, outClass = outClass),
spelling = spelling_check(v, v.type,
upLimit = options$spelling$upLimit,
silent = silent, outClass = outClass))
}
names(res) <- checks
class(res) <- c('checkResult.306.all_check')
return(res)
}
all_check(v)
runApp()
} else {
#' @param data imported dataset to be checked
#' @param info information about variables which will be used to check data
#' @param id name of variable that contains subejct identification
#' @param check_missing vector of variables to check missingness
#' @param plot whether create a plot of distribution of all variables or not
#' @param prefix prefix in name of output
#' @param outdir directory of output
#'
#' @return .csv file that contains list of potential errors
#' @export
inspect.data <- function(data, info, id, check_missing, plot = FALSE, prefix = "", outdir){
if (missing(outdir)) outdir <- "."
# select variables to check
data <- data[,names(data)[names(data) %in% info$varname]]
info <- info[match(names(data), info$varname),]
# check missing
if (missing(check_missing)) {
info$check_missing <- TRUE
} else {
info$check_missing <- check_missing
}
## check data
output <- do.call("rbind", mapply(inspect.each,
x = as.list(data),
varname = info$varname,
value = info$value,
type = info$type,
check_missing = info$check_missing))
## add id: use "=""...""" to avoid Excel to interpret string as Date
if (!missing(id) & !is.null(output)) {
output[, id] <- paste('"=""', as.character(data[output$index, id]), '"""', sep = "")
output <- output[, c(id, "index", "error")]
}
## plot distribution of data
if (plot) {
pdf(file = file.path(outdir, paste(prefix, "distribution.pdf", sep = "_")), width = 12, height = 10, family = "Helvetica", fonts = NULL, paper = "a4r")
layout(matrix(c(1:12), ncol = 4, nrow = 3, byrow = TRUE), respect = TRUE)
for (i in (1:length(info$varname))) {
if (length(na.omit(data[, info$varname[i]])) == 0) {
plot(x = 1:10, y = 1:10, main = info$varname[i], type = "n", xlab = "", ylab = "")
text(x = 5, y = 5, labels = "No non-missing value")
} else {
if (mode(data[, info$varname[i]]) != "numeric" | is.factor(data[, info$varname[i]])) {
barplot(table(data[, info$varname[i]]), main = info$varname[i])
} else {
if (is.POSIXct(data[, info$varname[i]])) {
boxplot(as.Date(data[, info$varname[i]]), main = info$varname[i])
} else {
boxplot(data[, info$varname[i]], main = info$varname[i])
}
}
}
}
dev.off()
}
## write output
if (!is.null(output)) {
write.csv(output, file = file.path(outdir, paste(prefix, "error.csv", sep = "_")), quote = FALSE, row.names = FALSE)
return(output)
} else {
cat("No error was found !")
}
}
IDAR:::datacheck_addin()
IDAR:::datacheck_createinfo_addin()
runApp()
IDAR:::datacheck_addin()
runApp()
runApp()
IDAR:::datacheck_addin()
runApp()
ae
ae$SUBJID2 = ae$SUBJID + 0.1
ae
write.csv(ae,file = ../../ae2.csv)
write.csv(ae,file = '../../ae2.csv')
runApp()
runApp()
IDAR:::datacheck_createinfo_addin()
IDAR:::datacheck_createinfo_addin
View(IDAR:::datacheck_createinfo_addin)
install.packages('handsontable')
runApp()
runApp()
